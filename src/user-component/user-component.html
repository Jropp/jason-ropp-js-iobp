<!-- Bugs
	1. When you edit the user, it doesn't display an "Edit user header"
		Currently the default is edit mode, but if there isn't a user then it is in create mode (the only difference is the setting the header display)

		FIXED: Sort of fixed in toggle class function with this.mode = 'edit/display';

	2. User card hould display 'no current user selected' if a user is not passed into it.

	3. Polyfill for safari required input popup
		x. check for use of safari
		x. enables popup window on required fields

	4. Required field only works if I interrupt the process with my checkFields function
-->

<link rel="import" href="polymer.html">
<dom-module id="user-component">
	<template>
		<style>
			:host {
				display: block;
			}

			.default-card {
				background-color: white;
				min-width: 300px;
				width: fit-content;
				padding: 15px;
				margin: 5px;
				border-radius: 5px;
				box-shadow: 3px 3px 2px lightgrey;
			}

			.default-card>input .first-name .last-name {
				width: 20px;
			}

			input {
				margin: 5px;
				border: none;
				font-size: 20px;
			}

			.email {
				font-size: 14px;
				width: 50%;
			}

			.id {
				font-size: 20px;
				margin-left: 6px;
			}

			.edit {
				border-bottom: lightgray solid 1px;
			}

			button {
				margin: 10px;
			}

			.empty-field-pop-up {
				position: absolute;
				top: 25%;
				left: 25%;
				z-index: 2;
				background-color: pink;
				height: 200px;
				width: 300px;
			}
		</style>


		<!-- HOW DO I COMBINE THESE TWO TO BE ON ONE TEMPLATE? -->
		<!-- <template is="dom-if" if="[[isInMode(mode, 'display')]]">
			<template is="dom-if" if="[[!user.id]]">
				<p>You have not selected a user</p>
			</template>
		</template> -->
		<div class="form-box">
			<form autocomplete="on">
				<div id="editUserFields" class="default-card">
					<h1>[[headerMessage(mode)]]</h1>
					<!-- bplint-disable no-auto-binding -->
					<fieldset>
						<legend>
							Name:
						</legend>
						<input id="editfName" type="text" class="first-name edit" placeholder="First" autocomplete="given-name" value="{{user.first::change}}"
						 required>
						<input id="editlName" type="text" class="last-name edit" placeholder="Last" autocomplete="family-name" value="{{user.last::change}}"
						 required>
					</fieldset>
					<fieldset>
						<legend>Contact:</legend>
						<label for="editEmail">
							<input id="editEmail" type="email" class="email edit" placeholder="email" autocomplete="email" value="{{user.email::change}}"
							 name="email" required>
						</label>
						<br>
						<label for="editPhone">
							<input id="editPhone" type="tel" class="phone edit" placeholder="phone" autocomplete="tel" value="{{user.phone::change}}"
							 required>
						</label>
					</fieldset>
					<fieldset>
						<legend>Other:</legend>
						<label for="editDepartment">
							<input id="editDepartment" class="department edit" placeholder="Department" value="{{user.department::change}}" required/>
						</label>
						<p class="id">[[idDisplay(user)]]</p>
					</fieldset>
					<!-- bplint-enable no-auto-binding -->

					<div class="submit-button-box">
						<button class="form-button" on-click="saveNewOrEdit" type="submit">Save</button>
						<button class="form-button" on-click="toggleEditable" type="submit">Edit</button>
						<template is="dom-if" if="[[user.id]]">
							<button class="form-button" on-click="deleteUser" type="submit">Delete</button>
						</template>
					</div>
				</div>
			</form>
		</div>

	</template>
	<script>
		'use strict';
		class UserComponent extends Polymer.Element {
			static get is() { return 'user-component'; }
			static get properties() {
				return {
					collapsed: {
						type: Boolean,
						value: false,
					},
					// edit, display
					mode: {
						type: String,
					},
					noSelectedUserToDisplay: {
						type: Boolean,
					},
					user: {
						type: Object,
						value: function () {
							return {
								first: '',
								last: '',
								phone: '',
								email: '',
								department: '',
								id: ''
							}
						}
					},
					users: {
						type: Array,
						value: () => JSON.parse(localStorage.getItem('onboardProjectUsers')) || []
					}
				};
			}

			connectedCallback() {
				super.connectedCallback();

				// The default mode is editable, this changes that to display
				if (this.mode === 'display') {
					this.toggleEditable();
				}
			}

			createNewUserId() {
				let id = '';
				// returns 9 random letters/symbols/numbers and pushes them into the id.
				for (let i = 0; i < 9; i++) { // eslint-disable-line no-magic-numbers
					let number = Math.random() * (90); // eslint-disable-line no-magic-numbers
					id += String.fromCharCode(Math.floor(number + 33)); // eslint-disable-line no-magic-numbers
				}

				// Checks to see if the created id is a duplicate of another users id, if so it creates a new id until successful
				let idAlreadyExists = this.getIdIndex(id);
				return (idAlreadyExists) ? this.createNewUserId() : id;
			}

			// Makes sure all fields are filled
			// FIXME: Currently fires even when all fields are filled
			// Why the heck does the auto complete work when this is up but not when it isn't, even though this has nothing to do with the autocomplete
			checkFields() {
				for (let prop in this.user) {
					if (!this.user[prop]) {
						return false;
					}
				}
				return true;
			}

			deleteUser() {
				let userIndex = this.getIdIndex(this.user.id);
				this.users.splice(userIndex, 1);
				this.updateLocalStorage();
			}


			// This is used to get the index for deleting or updating a users information.
			// This is also used when a new users id is created to see if that id already exists
			getIdIndex(id) {
				let index = (this.users) ? this.users.findIndex(val => val.id === id) : -1;
				// Returns false if id does not exist
				return (index === -1) ? false : index;
			}

			headerMessage(mode) {
				if (mode === 'edit') {
					// If there is not a user id then it means it is an instance of creating a user
					return (this.user.id) ? `Edit: ${this.user.first}, ${this.user.last}` : "Create User:"
				} else {
					// Display mode is currently an empty string
					return '';
				}
			}

			isUser(user) {
				return user.id ? true : false;
			}

			idDisplay(user) {
				return (user.id) ? `ID: ${user.id}` : "";
			}

			saveNewOrEdit(e) {
				if (this.checkFields()) {
					if (!this.user.id) {
						this.saveNewUser();
					} else {
						this.saveUserEdit(e);
					}
					this.toggleEditable();
					// if (this.collapsed) {
					// 	this.toggleCollapse();
					// }
				}
			}


			saveNewUser() {
						this.user.id = this.createNewUserId();
					this.users.splice(0, 0, this.user);
					this.updateLocalStorage();
				}

			saveUserEdit(e) {
						let index = this.getIdIndex(this.user.id);
					this.users.splice(index, 1, this.user);
					this.toggleMode();
					this.updateLocalStorage();
				}

			toggleCollapse() {
						this.collapsed = !this.collapsed;
					}

			toggleMode() {
						this.mode = (this.mode === 'edit') ? 'display' : 'edit';
					}

			toggleClass(field) {
						let name = field.className;

				if (name.match(/edit/)) {
						field.className = name.replace(/edit/, "");
					// This pokes the mode so that the card header updates display. Fixes bug but probably should be somewhere else.
					this.mode = 'display';
				}

				if (!name.match(/edit/)) {
						field.className = name + ' edit';
					// This pokes the mode so that the card header updates display. Fixes bug but probably should be somewhere else.
					this.mode = 'edit';
				}
			}

			toggleEditable(e) {
				if (e) {
						e.preventDefault();
					}
					let inputs = this.shadowRoot.querySelectorAll('input');
				for (let field of inputs) {
						field.readOnly = field.readOnly !== true;

					// If it was a click event it means it was from clicking the edit button
					this.toggleClass(field);

				}

			}

			updateLocalStorage() {
						localStorage.setItem('onboardProjectUsers', JSON.stringify(this.users));
			}

				}

				customElements.define(UserComponent.is, UserComponent);
			</script>
</dom-module>
