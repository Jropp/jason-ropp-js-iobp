<!-- bplint-disable no-unused-import -->
<link rel="import" href="~@banno/polymer/lib/elements/dom-if.js">
<link rel="import" href="~@banno/polymer/polymer-element.js">
<!-- bplint-enable no-unused-import -->

<dom-module id="user-component">
  <template>
    <style>
      :host {
        display: block;
      }

      .default-card {
        width: fit-content;
        min-width: 500px;
        min-height: 400px;
        margin: 5px;
        padding: 15px;
        border: #7395ae 1px solid;
        border-radius: 5px;
        box-shadow: 3px 3px 2px lightgrey;
        background-color: white;
      }

      fieldset {
        margin: 10px;
        border: #7395ae 2px solid;
        border-radius: 3px;
      }

      .default-card>input .first-name .last-name {
        width: 20px;
      }

      input {
        margin: 5px;
        border: none;
        font-size: 20px
      }

      .edit {
        border-bottom: lightgray solid 1px;
      }

      .email {
        width: 50%;
      }

      .id {
        font-size: 20px;
      }

      button {
        margin: 10px;
        width: 60px;
        height: 30px;
        border-radius: 3px;
        background-color: #7395ae;
      }

      .warning {
        color: red;
        font-size: 20px;
      }
    </style>

    <div id="checkForEmptyFields" class="default-card">
      <form on-input="formWatcher" autocomplete="on">
        <h1>[[headerMessage(mode)]]</h1>
        <!-- bplint-disable no-auto-binding -->
        <template is="dom-if" if="[[isMode(modes.EDIT, mode)]]">
          <fieldset>
            <label for="firstName">First:</label>
            <input id="firstName" type="text" class="first-name edit" placeholder="First" autocomplete="given-name" value="{{user.first::change}}"
              required>

            <label for="lastName">Last:</label>
            <input id="lastName" type="text" class="last-name edit" placeholder="Last" autocomplete="family-name" value="{{user.last::change}}"
              required>
          </fieldset>
        </template>
        <template is="dom-if" if="[[isMode(modes.DISPLAY, mode)]]">
          <h1>[[user.last]], [[user.first]]</h1>
          <p class="warning">[[warningMessage]]</p>
        </template>

        <fieldset>
          <label for="email">Email:</label>
          <input id="email" type="email" class="email edit" placeholder="email" autocomplete="email" value="{{user.email::change}}"
            name="email" required>
          <br>

          <label for="phone">Phone:</label>
          <input id="phone" type="tel" class="phone edit" placeholder="(xxx) xxx-xxxx" autocomplete="tel" value="{{user.phone::change}}"
            required>
          <br>

          <template is="dom-if" if="[[isMode(modes.EDIT, mode)]]">
            <p class="warning">[[phoneFormatMessage]]</p>
          </template>

          <label for="department">Department:</label>
          <input id="department" class="department edit" placeholder="Department" value="{{user.department::change}}" required/>
        </fieldset>

        <template is="dom-if" if="[[user.id]]">
          <fieldset>
            <div id="id">
              <h3>ID:</h3>
              <p class="id">[[user.id]]</p>
            </div>
          </fieldset>
        </template>
        <!-- bplint-enable no-auto-binding -->
        <div class="submit-button-box">

          <template is="dom-if" if="[[isMode(modes.EDIT, mode)]]">
            <button on-click="save" type="submit" disabled="[[disableSave]]">Save</button>

            <template is="dom-if" if="[[user.id]]">
              <button on-click="delete" type="submit" formnovalidate>Delete</button>
            </template>

            <template is="dom-if" if="[[!user.id]]">
              <button on-click="cancel" formnovalidate>Cancel</button>
            </template>

            <p class="warning">[[warningMessage]]</p>


          </template>

          <template is="dom-if" if="[[isMode(modes.DISPLAY, mode)]]">
            <button on-click="editButtonClicked" type="submit" disabled="[[editOpen]]">Edit</button>
          </template>

        </div>

      </form>
    </div>
  </template>
  <script type="module">
    import { Element as PolymerElement } from '@banno/polymer/polymer-element.js'; // eslint-disable-line no-unused-vars
    import { database } from './../api/user-database.js';
    class UserComponentElement extends PolymerElement {
      static get is() { return 'user-component'; }
      static get properties() {
        return {
          // edit, display
          mode: {
            type: String,
          },
          modes: {
            type: Object,
            value: () => {
              return {
                DISPLAY: 'display',
                EDIT: 'edit'
              };
            }
          },
          user: {
            type: Object,
            value: () => {
              return {
                first: '',
                last: '',
                phone: '',
                email: '',
                department: '',
                id: ''
              };
            }
          },
          disableSave: {
            type: Boolean,
            value: true,
          },
          editOpen: {
            type: Boolean,
            value: false,
            observer: 'whenEditOpenChanges'
          },
          warningMessage: {
            type: String,
          },
          phoneFormatMessage: {
            type: String,
          },
          userToDisplay: {
            type: Object,
            observer: 'formatUserData'
          }
        };
      }

      connectedCallback() {
        super.connectedCallback();
        this.initDisplayCard();
      }

      initDisplayCard() {
        if (this.isMode(this.modes.DISPLAY)) {
          this.toggleEditable();
        }
      }

      cancel(e) {
        e.preventDefault();

        this.dispatchEvent(new CustomEvent('cancel', {
          bubbles: true,
          composed: true,
        }));

        this.resetFormState();
      }

      // TODO: Is there a way to get rid of let fieldsEmpty without breaking functionality?
      fieldsEmpty() {
        let fields = this.shadowRoot.querySelectorAll('input');
        let fieldsEmpty = false;

        fields.forEach(field => {
          if (!field.value.length) {
            fieldsEmpty = true;
          }
        });

        return fieldsEmpty;
      }

      checkPhoneFormat(phone) {
        // FIXME: BUG currently a too long phone number is passing the test. The problem is that the optional country code is not erroring out if its too long, it just matches using the other non optional parts

        // Pseudocode fix

        // ^ 1-3d (\s | -) plus area code OR just area code

        let optCountryCode = '(^\\d{1,3})?';
        let optDash = '[-\\s]?';
        let areaCode = '(^)?\\(?\\d{3}\\)?';
        let threeDigit = '\\d{3}';
        let fourDigit = '\\d{4}$';
        // new RegExp(optCountryCode + optDash + areaCode + optDash + threeDigit + optDash + fourDigit);
        let phoneFormat = /(^\d{1,3})?((\s|-))?(^)?(\()?\d\d\d(\))?((\s|-))?\d\d\d((\s|-))?\d\d\d\d$/
        return phoneFormat.test(phone);
      }

      clearNewUserForm() {
        this.shadowRoot.querySelector('form').reset();

        this.disableSave = true;
        for (let key of Object.keys(this.user)) {
          this.user[key] = '';
        }
      }

      delete(e) {
        e.preventDefault();

        database.deleteUser(this.user);
        this.editInProgress(false);
        this.mode = this.modes.DISPLAY;
        this.toggleEditable();
      }

      editButtonClicked(e) {
        e.preventDefault();
        this.editInProgress(true);
        this.toggleMode();
      }

      editInProgress(bool) {
        this.dispatchEvent(new CustomEvent('editInProgress', {
          bubbles: true,
          composed: true,
          detail: bool
        }));
      }

      formatUserData(user) {
        if (user.id.length) {
          user.phone = this.insertPhoneSymbols(user.phone);
          this.user = user;
        }
      }

      formWatcher() {
        if (this.editOpen || this.fieldsEmpty()) {
          this.disableSave = true;
        }

        if (!this.fieldsEmpty()) {
          debugger;
          this.disableSave = false;
        }
      }

      headerMessage(mode) {
        if (mode === this.modes.EDIT) {
          return this.user.id ? `Edit: ${this.user.first}, ${this.user.last}` : 'Create User:';
        }
        return '';
      }

      insertPhoneSymbols(phoneNumber) {
        let phoneArray = phoneNumber.split('');
        phoneArray = phoneArray.reverse();
        let domesticSymbols = [
          { name: 'dash', loc: 4, text: '-' },
          { name: 'spaceLoc', loc: 8, text: ' ' },
          { name: 'leftParLoc', loc: 9, text: ')' },
          { name: 'rightParLoc', loc: 13, text: '(' }
        ];

        domesticSymbols.forEach(symbol => {
          phoneArray.splice(symbol.loc, 0, symbol.text);
        });

        let domesticNumLength = 14;
        let interSpaceLoc = 14;
        if (phoneArray.length > domesticNumLength) {
          phoneArray.splice(interSpaceLoc, 0, ' ');
          let internationalNumPre = '+';
          phoneArray.push(internationalNumPre);
        }

        phoneArray = phoneArray.reverse();
        return phoneArray.join('');
      }

      isMode(expectedMode) {
        return (expectedMode === this.mode);
      }

      resetFormState(isEditedUser) {
        this.phoneFormatMessage = '';
        this.editInProgress(false);

        if (isEditedUser) {
          this.toggleMode();
        } else {
          this.clearNewUserForm();
        }

      }

      save(e) {
        e.preventDefault();
        if (this.checkPhoneFormat(this.user.phone)) {

          let user = Object.assign({}, this.user);

          if (user.id) {
            database.editUser(user);
          } else {
            database.saveUser(user);
          }

          this.resetFormState(this.user.id);
        } else {
          this.phoneFormatMessage = 'Please format phone number as (xxx) xxx-xxxx';
        }
      }

      toggleMode(e) {
        this.mode = this.isMode(this.modes.EDIT) ? this.modes.DISPLAY : this.modes.EDIT;
        this.toggleEditable();
      }

      toggleEditable() {
        this.shadowRoot.querySelectorAll('input')
          .forEach(input => {
            let name = input.className;

            input.className = this.isMode(this.modes.DISPLAY) ? name.replace(/\sedit/, '') : name + ' edit';
            input.readOnly = this.isMode(this.modes.DISPLAY);
          });
      }

      whenEditOpenChanges(editOpen) {
        if (!this.user.id) {
          this.disableSave = editOpen || this.fieldsEmpty();
          this.warningMessage = editOpen ? 'Please save other user edits before saving this one.' : '';
        } else {
          this.disableSave = false;
        }

      }

    }

    customElements.define(UserComponentElement.is, UserComponentElement);
    export default UserComponentElement;
  </script>
</dom-module>
